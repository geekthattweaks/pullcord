package monitor

import (
	"github.com/fitstar/falcore"
	"github.com/stretchr/testify/assert"
	"github.com/stuphlabs/pullcord"
	"net"
	"strconv"
	"testing"
	"time"
)

// serveLandingPage is a testing helper function that creates a webserver that
// other tests for MinSession can use to verify monitoring service.
func serveLandingPage(landingServer *falcore.Server) {
	err := landingServer.ListenAndServe()
	if err != nil {
		panic(err)
	}
}

// TestMinMonitorUpService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorUpService(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(pullcord.NewLandingFilter())
	landingServer := falcore.NewServer(0, landingPipeline)
	go serveLandingPage(landingServer)
	defer landingServer.StopAccepting()

	<- landingServer.AcceptReady

	service, err := NewMonitorredService(
		testHost,
		landingServer.Port(),
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorDownService(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	server, err := net.Listen(testProtocol, ":0")
	assert.NoError(t, err)
	_, rawPort, err := net.SplitHostPort(server.Addr().String())
	assert.NoError(t, err)
	testPort, err := strconv.Atoi(rawPort)
	assert.NoError(t, err)
	err = server.Close()
	assert.NoError(t, err)

	svc, err := NewMonitorredService(
		testHost,
		testPort,
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorInvalidService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorInvalidService(t *testing.T) {
	testServiceName := "test"
	testHost := "256.256.256.256.256"
	testPort := 80
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	svc, err := NewMonitorredService(
		testHost,
		testPort,
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.False(t, up)
}

// TestMinMonitorUpReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorUpReprobe(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(pullcord.NewLandingFilter())
	landingServer := falcore.NewServer(0, landingPipeline)
	go serveLandingPage(landingServer)
	defer landingServer.StopAccepting()

	<- landingServer.AcceptReady

	svc, err := NewMonitorredService(
		testHost,
		landingServer.Port(),
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorDownReprobe(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	server, err := net.Listen(testProtocol, ":0")
	assert.NoError(t, err)
	_, rawPort, err := net.SplitHostPort(server.Addr().String())
	assert.NoError(t, err)
	testPort, err := strconv.Atoi(rawPort)
	assert.NoError(t, err)
	err = server.Close()
	assert.NoError(t, err)

	svc, err := NewMonitorredService(
		testHost,
		testPort,
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorSetStatusUp(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	server, err := net.Listen(testProtocol, ":0")
	assert.NoError(t, err)
	_, rawPort, err := net.SplitHostPort(server.Addr().String())
	assert.NoError(t, err)
	testPort, err := strconv.Atoi(rawPort)
	assert.NoError(t, err)
	err = server.Close()
	assert.NoError(t, err)

	svc, err := NewMonitorredService(
		testHost,
		testPort,
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)

	mon.SetStatusUp(testServiceName)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorFalsePositive verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorFalsePositive(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(pullcord.NewLandingFilter())
	landingServer := falcore.NewServer(0, landingPipeline)
	go serveLandingPage(landingServer)

	<- landingServer.AcceptReady

	service, err := NewMonitorredService(
		testHost,
		landingServer.Port(),
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	landingServer.StopAccepting()

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorTrueNegative verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorTrueNegative(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(pullcord.NewLandingFilter())
	landingServer := falcore.NewServer(0, landingPipeline)
	go serveLandingPage(landingServer)

	<- landingServer.AcceptReady

	service, err := NewMonitorredService(
		testHost,
		landingServer.Port(),
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	landingServer.StopAccepting()

	// Unfortunately, falcore.Server does not provide an externally visible
	// channel for indicating when the server is down like it does for when
	// the server is up.
	sleepTime, err := time.ParseDuration("5s")
	assert.NoError(t, err)
	time.Sleep(sleepTime)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantStatus verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorNonExistantStatus(t *testing.T) {
	testServiceName := "test"

	mon := NewMinMonitor()

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorNonExistantSetStatusUp(t *testing.T) {
	testServiceName := "test"

	mon := NewMinMonitor()

	err := mon.SetStatusUp(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
}

// TestMinMonitorNonExistantReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorNonExistantReprobe(t *testing.T) {
	testServiceName := "test"

	mon := NewMinMonitor()

	up, err := mon.Reprobe(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorAddExistant verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorAddExistant(t *testing.T) {
	testServiceName := "test"
	testHost := "localhost"
	testProtocol := "tcp"
	gracePeriod := time.Duration(0)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(pullcord.NewLandingFilter())
	landingServer := falcore.NewServer(0, landingPipeline)
	go serveLandingPage(landingServer)
	defer landingServer.StopAccepting()

	<- landingServer.AcceptReady

	svc, err := NewMonitorredService(
		testHost,
		landingServer.Port(),
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	mon := NewMinMonitor()
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	svc2, err := NewMonitorredService(
		testHost,
		landingServer.Port() + 1,
		testProtocol,
		gracePeriod,
	)
	assert.NoError(t, err)
	err = mon.Add(
		testServiceName,
		svc2,
	)
	assert.Error(t, err)
	assert.Equal(t, DuplicateServiceRegistrationError, err)
}
