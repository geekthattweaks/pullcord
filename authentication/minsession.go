package authentication

import (
	"bytes"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	// "github.com/stuphlabs/pullcord"
	"net/http"
	"regexp"
	"strconv"
)

const minSessionCookieNameRandSize = 32
const minSessionCookieValueRandSize = 128
const minSessionCookieMaxAge = 2 * 60 * 60

const rngCollisionError = errorString(
	"The random number generator produced a colliding value. This is" +
	" perfectly fine if it occurs extremely rarely, but if it occurs" +
	" more than once, it would be extremely concerning.",
)

// MinSessionHandler is a somewhat minimalist form of a SessionHandler.
type MinSessionHandler struct {
	table  map[string]*MinSession
	name   string
	path   string
	domain string
}

// NewMinSessionHandler constructs a new MinSessionHandler given a unique name
// (which will be given to all the cookies), and a path and domain (the two of
// which will simply be sent to the browser along with the cookie, and otherwise
// have no bearing on functionality).
func NewMinSessionHandler(
	handlerName string,
	handlerPath string,
	handlerDomain string,
) *MinSessionHandler {
	log().Info("initializing minimal session handler")

	var result MinSessionHandler
	result.table = make(map[string]*MinSession)
	result.name = handlerName
	result.path = handlerPath
	result.domain = handlerDomain

	return &result
}

func (handler *MinSessionHandler) GetSession() (Session, error) {
	log().Info("minsessionhandler is generating a new session")
	log().Debug(
		fmt.Sprintf(
			"minsession being generated by minsessionhandler: %v",
			handler,
		),
	)

	var sesh MinSession
	var ims internalMinSession
	sesh.ion = &ims
	sesh.ion.data = make(map[string]interface{})
	sesh.handler = handler
	return &sesh, nil
}

func (handler *MinSessionHandler) genCookie() (*http.Cookie, error) {
	log().Debug("minsession generating cookie")

	var randReadErr error
	var otherErr error

	nbytes := make([]byte, minSessionCookieNameRandSize)
	vbytes := make([]byte, minSessionCookieValueRandSize)

	cookie_name := ""
	name_gen_needed := true
	for name_gen_needed {
		_, randReadErr = rand.Read(nbytes)
		if randReadErr != nil {
			log().Err(
				"minsession cookie generation was unable to" +
				" read the needed random bytes",
			)
			return nil, randReadErr
		}

		cookie_name = handler.name + "-" + hex.EncodeToString(nbytes)
		// Slower than adding an else on the next if, but clearer.
		name_gen_needed = false

		_, collision := handler.table[cookie_name]
		if collision {
			// We had a collision with an existing legit cookie?
			// Is the random number generator broken?
			log().Err(
				fmt.Sprintf(
					"minsession cookie generation has" +
					" created a new cookie with a name" +
					" that collides with an already" +
					" existing cookie from the cookie" +
					" table which shares the name: %s",
					cookie_name,
				),
			)
			name_gen_needed = true
			otherErr = rngCollisionError
		}
	}

	_, randReadErr = rand.Read(vbytes)
	if randReadErr != nil {
		log().Err(
			"minsession cookie generation was unable to" +
			" read the needed random bytes",
		)
		return nil, randReadErr
	}

	var cke http.Cookie
	cke.Name = cookie_name
	// TODO delete
	log().Debug(fmt.Sprintf("got %v", handler))
	cke.Value = hex.EncodeToString(vbytes)
	cke.Path = handler.path
	cke.Domain = handler.domain
	cke.MaxAge = minSessionCookieMaxAge
	cke.Secure = true
	cke.HttpOnly = true

	return &cke, otherErr
}

type internalMinSession struct {
	cvalue string
	data   map[string]interface{}
}

type MinSession struct {
	ion *internalMinSession
	handler *MinSessionHandler
}

func (sesh *MinSession) GetValue(key string) (interface{}, error) {
	log().Debug(fmt.Sprintf("minsession requesting value for: %s", key))

	value, present := sesh.ion.data[key]
	if ! present {
		return nil, NoSuchSessionValueError
	} else {
		return value, nil
	}
}

func (sesh *MinSession) GetValues() (map[string]interface{}) {
	log().Debug("minsession requesting all values")

	return sesh.ion.data
}

func (sesh *MinSession) SetValue(key string, value interface{}) (error) {
	log().Debug(fmt.Sprintf("minsession setting value for: %s", key))

	sesh.ion.data[key] = value
	return nil
}

// CookieMask for the MinSession is an implementation of the CookieMask
// function required by all Session derivatives.
func (sesh *MinSession) CookieMask(incomingCookies []*http.Cookie) (
	forwardedCookies []*http.Cookie,
	setCookies []*http.Cookie,
	err error,
) {
	log().Debug("running minsession cookiemask")

	new_cookie_needed := true
	cookieNameRegex := regexp.MustCompile(
		"^" +
		sesh.handler.name +
		"-[0-9A-Fa-f]{" +
		strconv.Itoa(minSessionCookieNameRandSize * 2) +
		"}$",
	)

	in_ckes_buffer := new(bytes.Buffer)
	for _, cookie := range incomingCookies {
		in_ckes_buffer.WriteString("\"" + cookie.Name + "\",")

		if cookieNameRegex.MatchString(cookie.Name) {
			sesh2, present := sesh.handler.table[cookie.Name]
			if present &&
			    len(cookie.Value) > 0 &&
			    cookie.Value == sesh2.ion.cvalue {
				log().Debug(
					fmt.Sprintf(
						"minsession cookiemask" +
						" received valid cookie with" +
						" name: %s",
						cookie.Name,
					),
				)

				new_cookie_needed = false

				// In the more common scenario where a new
				// empty session was created, it would probably
				// be faster to copy any recently set values
				// into the already established session than
				// vice-versa.
				for key, val := range sesh.ion.data {
					sesh2.ion.data[key] = val
				}

				// This should replace a new empty session with
				// an already established one, but I think it
				// would work as expected with two already
				// established sessions as well? I hope so, at
				// least... Anyway, we can't just exit here in
				// case such a scenario occurs.
				sesh.ion = sesh2.ion
			} else {
				if present {
					// TODO: configurable info vs warn?
					log().Info(
						fmt.Sprintf(
							"minsession" +
							" cookiemask received" +
							" bad cookie value" +
							" for valid cookie" +
							" name: %s",
							cookie.Name,
						),
					)

					delete(sesh.handler.table, cookie.Name)

					// TODO: should this destroy every
					// session that is touched?
				} else {
					log().Info(
						fmt.Sprintf(
							"minsession" +
							" cookiemask received" +
							" matching but" +
							" invalid cookie with" +
							" name: %s",
							cookie.Name,
						),
					)
				}

				var bad_cookie http.Cookie
				bad_cookie.Name = cookie.Name
				bad_cookie.Value = cookie.Value
				bad_cookie.MaxAge = -1
				setCookies = append(setCookies, &bad_cookie)
			}
		} else {
			forwardedCookies = append(forwardedCookies, cookie)
		}
	}
	log().Debug(
		fmt.Sprintf(
			"minsession cookiemask received cookies with these" +
			" cookie names: [%s]",
			in_ckes_buffer.String(),
		),
	)

	if new_cookie_needed {
		log().Debug(
			"minsession cookiemask needs to generate a new cookie",
		)

		new_cookie, err := sesh.handler.genCookie()
		if new_cookie == nil {
			log().Err(
				fmt.Sprintf(
					"minsession cookiemask ran into" +
					" unexpected, unrecoverable  errors" +
					" during cookie generation: %s",
					err,
				),
			)
		} else if err != nil && err != rngCollisionError {
			log().Warning(
				fmt.Sprintf(
					"minsession cookiemask ran into" +
					" unexpected but apparently" +
					" recoverable errors during cookie" +
					" generation: %s",
					err,
				),
			)
		}

		setCookies = append(setCookies, new_cookie)
		log().Info(
			fmt.Sprintf(
				"minsession cookiemask has added a new cookie" +
				" with name: %s",
				new_cookie.Name,
			),
		)

		sesh.ion.cvalue = new_cookie.Value
		sesh.handler.table[new_cookie.Name] = sesh
		log().Debug(
			fmt.Sprintf(
				"minsession cookiemask has created a new" +
				" session to go with the new cookie with" +
				" name: %s",
				new_cookie.Name,
			),
		)
	}

	return forwardedCookies, setCookies, nil
}
